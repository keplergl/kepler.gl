"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.DeleteDatasetModal = void 0;

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var _react = _interopRequireDefault(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _datasetLabel = _interopRequireDefault(require("../common/dataset-label"));

var _localization = require("../../localization");

var _templateObject;

var StyledMsg = _styledComponents["default"].div(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["\n  margin-top: 24px;\n"])));

var DeleteDatasetModal = function DeleteDatasetModal(_ref) {
  var dataset = _ref.dataset,
      _ref$layers = _ref.layers,
      layers = _ref$layers === void 0 ? [] : _ref$layers;
  // retrieve only layers related to the current dataset
  var currDatasetLayers = layers.filter(function (layer) {
    return layer.config.dataId === (dataset && dataset.id);
  });
  return /*#__PURE__*/_react["default"].createElement("div", {
    className: "delete-dataset-modal"
  }, /*#__PURE__*/_react["default"].createElement(_datasetLabel["default"], {
    dataset: dataset
  }), /*#__PURE__*/_react["default"].createElement(StyledMsg, {
    className: "delete-dataset-msg"
  }, /*#__PURE__*/_react["default"].createElement(_localization.FormattedMessage, {
    id: 'modal.deleteData.warning',
    values: {
      length: currDatasetLayers.length
    }
  })));
};

exports.DeleteDatasetModal = DeleteDatasetModal;

var DeleteDatasetModalFactory = function DeleteDatasetModalFactory() {
  return DeleteDatasetModal;
};

var _default = DeleteDatasetModalFactory;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL21vZGFscy9kZWxldGUtZGF0YS1tb2RhbC5qcyJdLCJuYW1lcyI6WyJTdHlsZWRNc2ciLCJzdHlsZWQiLCJkaXYiLCJEZWxldGVEYXRhc2V0TW9kYWwiLCJkYXRhc2V0IiwibGF5ZXJzIiwiY3VyckRhdGFzZXRMYXllcnMiLCJmaWx0ZXIiLCJsYXllciIsImNvbmZpZyIsImRhdGFJZCIsImlkIiwibGVuZ3RoIiwiRGVsZXRlRGF0YXNldE1vZGFsRmFjdG9yeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxJQUFNQSxTQUFTLEdBQUdDLDZCQUFPQyxHQUFWLDZHQUFmOztBQUlPLElBQU1DLGtCQUFrQixHQUFHLFNBQXJCQSxrQkFBcUIsT0FBNEI7QUFBQSxNQUExQkMsT0FBMEIsUUFBMUJBLE9BQTBCO0FBQUEseUJBQWpCQyxNQUFpQjtBQUFBLE1BQWpCQSxNQUFpQiw0QkFBUixFQUFRO0FBQzVEO0FBQ0EsTUFBTUMsaUJBQWlCLEdBQUdELE1BQU0sQ0FBQ0UsTUFBUCxDQUFjLFVBQUFDLEtBQUs7QUFBQSxXQUFJQSxLQUFLLENBQUNDLE1BQU4sQ0FBYUMsTUFBYixNQUF5Qk4sT0FBTyxJQUFJQSxPQUFPLENBQUNPLEVBQTVDLENBQUo7QUFBQSxHQUFuQixDQUExQjtBQUVBLHNCQUNFO0FBQUssSUFBQSxTQUFTLEVBQUM7QUFBZixrQkFDRSxnQ0FBQyx3QkFBRDtBQUFjLElBQUEsT0FBTyxFQUFFUDtBQUF2QixJQURGLGVBRUUsZ0NBQUMsU0FBRDtBQUFXLElBQUEsU0FBUyxFQUFDO0FBQXJCLGtCQUNFLGdDQUFDLDhCQUFEO0FBQ0UsSUFBQSxFQUFFLEVBQUUsMEJBRE47QUFFRSxJQUFBLE1BQU0sRUFBRTtBQUFDUSxNQUFBQSxNQUFNLEVBQUVOLGlCQUFpQixDQUFDTTtBQUEzQjtBQUZWLElBREYsQ0FGRixDQURGO0FBV0QsQ0FmTTs7OztBQWlCUCxJQUFNQyx5QkFBeUIsR0FBRyxTQUE1QkEseUJBQTRCO0FBQUEsU0FBTVYsa0JBQU47QUFBQSxDQUFsQzs7ZUFDZVUseUIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjEgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XG5pbXBvcnQgRGF0YXNldExhYmVsIGZyb20gJ2NvbXBvbmVudHMvY29tbW9uL2RhdGFzZXQtbGFiZWwnO1xuaW1wb3J0IHtGb3JtYXR0ZWRNZXNzYWdlfSBmcm9tICdsb2NhbGl6YXRpb24nO1xuXG5jb25zdCBTdHlsZWRNc2cgPSBzdHlsZWQuZGl2YFxuICBtYXJnaW4tdG9wOiAyNHB4O1xuYDtcblxuZXhwb3J0IGNvbnN0IERlbGV0ZURhdGFzZXRNb2RhbCA9ICh7ZGF0YXNldCwgbGF5ZXJzID0gW119KSA9PiB7XG4gIC8vIHJldHJpZXZlIG9ubHkgbGF5ZXJzIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnQgZGF0YXNldFxuICBjb25zdCBjdXJyRGF0YXNldExheWVycyA9IGxheWVycy5maWx0ZXIobGF5ZXIgPT4gbGF5ZXIuY29uZmlnLmRhdGFJZCA9PT0gKGRhdGFzZXQgJiYgZGF0YXNldC5pZCkpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJkZWxldGUtZGF0YXNldC1tb2RhbFwiPlxuICAgICAgPERhdGFzZXRMYWJlbCBkYXRhc2V0PXtkYXRhc2V0fSAvPlxuICAgICAgPFN0eWxlZE1zZyBjbGFzc05hbWU9XCJkZWxldGUtZGF0YXNldC1tc2dcIj5cbiAgICAgICAgPEZvcm1hdHRlZE1lc3NhZ2VcbiAgICAgICAgICBpZD17J21vZGFsLmRlbGV0ZURhdGEud2FybmluZyd9XG4gICAgICAgICAgdmFsdWVzPXt7bGVuZ3RoOiBjdXJyRGF0YXNldExheWVycy5sZW5ndGh9fVxuICAgICAgICAvPlxuICAgICAgPC9TdHlsZWRNc2c+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5jb25zdCBEZWxldGVEYXRhc2V0TW9kYWxGYWN0b3J5ID0gKCkgPT4gRGVsZXRlRGF0YXNldE1vZGFsO1xuZXhwb3J0IGRlZmF1bHQgRGVsZXRlRGF0YXNldE1vZGFsRmFjdG9yeTtcbiJdfQ==